#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import threading, yaml, re, os, argparse, concurrent.futures

results = {}
results_lock = threading.Lock()

class Result:
    def __init__(self, field="", status="", basename=""):
        self.field = field
        self.status = status
        self.basename = basename

    def print(self):
        print(self.field + self.status + self.basename, end="")


def status(file):
    if ".disabled" == os.path.splitext(file)[-1]:
        return "OFF"
    else:
        return "ON"

def basename(file):
    return re.match(r'(.+\.dtbo)', os.path.basename(file)).group(1)

def process_file(file, args, index):
    global results
    result = Result()
    try:
        field = yaml.load(os.popen("dtc -I dtb -O dts " + file + " 2>/dev/null | dtc -I dts -O yaml 2>/dev/null").read(), Loader=yaml.CLoader)[0]["metadata"][args.field][0].replace("\0", "\n")
        result.field = field + "\n"
    except Exception as e:
        if args.default_value == "file":
            result.field = file + "\n"
        else:
            result.field = args.default_value + "\n"
    if args.show_overlays:
        result.status = status(file) + "\n"
        result.basename = basename(file) + "\n"
    with results_lock:
        results[index] = result

def main():
    parser = argparse.ArgumentParser(description='Parse dtbo metadata data')
    parser.add_argument('--show-overlays', action='store_true', default=False, help='Control print DTBO title, enable status and DTBO filename')
    parser.add_argument('--default-value', metavar='string', default="null", help='error default string')
    parser.add_argument('field', metavar='string', help='Metadata field')
    parser.add_argument('filename', nargs='+', metavar='filename', help='DTBO filename list')
    args = parser.parse_args()

    yaml.CLoader.add_constructor('!u8', yaml.constructor.FullConstructor.construct_yaml_seq)

    global results
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = [executor.submit(process_file, file, args, i) for i, file in enumerate(args.filename)]
        concurrent.futures.wait(futures)
    for key, result in sorted(results.items()):
        result.print()

if __name__ == "__main__":
    main()
