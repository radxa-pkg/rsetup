#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import yaml, re, os, argparse, concurrent.futures

results = []

def status(file):
    if ".disabled" == os.path.splitext(file)[-1]:
        return "OFF"
    else:
        return "ON"

def basename(file):
    return re.match(r'(.+\.dtbo)', os.path.basename(file)).group(1)

def process_file(file, args, index):
    global results
    try:
        field = yaml.load(os.popen("dtc -I dtb -O dts " + file + " 2>/dev/null | dtc -I dts -O yaml 2>/dev/null").read(), Loader=yaml.CLoader)[0]["metadata"][args.field][0].replace("\0", "\n")
        results[index] = field + "\n"
    except Exception as e:
        if args.default_value == "file":
            results[index] = file + "\n"
        else:
            results[index] = args.default_value + "\n"
    if args.show_overlays:
        results[index+1] = status(file) + "\n"
        results[index+2] = basename(file) + "\n"

def main():
    parser = argparse.ArgumentParser(description='Parse dtbo metadata data')
    parser.add_argument('--show-overlays', action='store_true', default=False, help='Control print DTBO title, enable status and DTBO filename')
    parser.add_argument('--default-value', metavar='string', default="null", help='error default string')
    parser.add_argument('field', metavar='string', help='Metadata field')
    parser.add_argument('filename', nargs='+', metavar='filename', help='DTBO filename list')
    args = parser.parse_args()

    yaml.CLoader.add_constructor('!u8', yaml.constructor.FullConstructor.construct_yaml_seq)

    global results
    results = [""] * len(args.filename) * 3
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = [executor.submit(process_file, file, args, i * 3) for i, file in enumerate(args.filename)]
        concurrent.futures.wait(futures)
    print("".join(results), end="")

if __name__ == "__main__":
    main()
